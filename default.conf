# 1. Configure the RealIP module
# List all possible trusted proxy and load balancer IP ranges here
# Internal OpenShift cluster network
set_real_ip_from 10.128.0.0/14;
set_real_ip_from 172.30.0.0/16;
# Add more trusted proxies/load balancers as needed
# Example: Google's L7 Load Balancers
# set_real_ip_from 130.211.0.0/22;
# set_real_ip_from 35.191.0.0/16;

# Use X-Forwarded-For header to determine the real client IP
real_ip_header X-Forwarded-For;
# Cover multiple chained proxies and load balancers
real_ip_recursive on;

# 2. Configure the Geo module
geo $remote_addr $bypass_cidr {
    # Default policy: Deny all traffic
    default             0;

    127.0.0.1           1;  # Localhost
    10.128.0.0/14       1;  # Default OpenShift internal (CNO) network CIDR
    172.30.0.0/16       1;  # Default OpenShift service network CIDR

    # IMPORTANT: Dynamically generated list of hosts for which maintenance
    # mode should it not applicable. This includes worker nodes IPs and
    # required in order to allow cross-node communication when PODs are 
    # referring to each other using routes (e.g. MAS Manage OIDC cookie
    # validation) as well as other known locations (e.g. current host IP,
    # etc.) which should be allowed access at all times.
@BYPASS_CIDRS@
}

# 3. Add a map for the secret header

# Increase the hash bucket size for the map
map_hash_bucket_size    128;

map $http_x_bypass_key $bypass_key {
    default 0;
    "@BYPASS_KEY@" 1;
}

# 4. Add a map to combine both bypass methods
map "$bypass_cidr$bypass_key" $bypass {
    default 0; # 00 = No bypass
    "10"    1; # 1 (CIDR) + 0 (Secret) = Bypass
    "01"    1; # 0 (CIDR) + 1 (Secret) = Bypass
    "11"    1; # 1 (CIDR) + 1 (Secret) = Bypass
}

@UPSTREAMS@ 

map $host$uri $backend {
@BACKENDS@
}

# Additional logging of reverse proxy details for debugging purposes
log_format  proxy  '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" "$http_x_forwarded_for" '
                    '"$backend" "$upstream_addr"';
access_log  /var/log/nginx/access.log  proxy;

server {
    listen       8080;
    server_name  localhost;

    proxy_busy_buffers_size  512k;
    proxy_buffers         4  512k;
    proxy_buffer_size        256k;
    large_client_header_buffers    4    512k;
    client_max_body_size    20M;

    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        if ($bypass) {
          proxy_pass https://$backend$request_uri;
        }

        root   /usr/share/nginx/html;
        try_files $uri /maintenance.html;
    }

    location = /maintenance.html {
        internal;
        
        add_header "Cache-Control" "no-cache, no-store, must-revalidate";
        add_header "Pragma" "no-cache";
        add_header "Expires" "0";
        
        root   /usr/share/nginx/html;
    }

    # A special location to test proxy logic and headers
    location /ip-test {
        # Disable caching for this test
        add_header Cache-Control 'no-store, no-cache';
        
        # Return a 200 OK response with the test info
        return 200 "Your IP (realip): $remote_addr\nRaw X-Forwarded-For: $http_x_forwarded_for\nBackend: $backend\nBypass: $bypass\n";
    }
}
